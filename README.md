# Кастомный токен и Scroll мост L1/L2

Этот проект демонстрирует создание кастомных токенов и мостов для их передачи между Ethereum (L1) и Scroll (L2).

## Содержание

- [Установка](#установка)
- [Конфигурация](#конфигурация)
- [Использование](#использование)
  - [Деплой контрактов](#деплой-контрактов)
  - [Верификация контрактов](#верификация-контрактов)
  - [Перевод токенов с L1 на L2](#перевод-токенов-с-l1-на-l2)
  - [Перевод токенов с L2 на L1](#перевод-токенов-с-l2-на-l1)
  - [Клейм токенов с L2 на L1](#клейм-токенов-с-l2-на-l1)
  - [Веб-интерфейс](#веб-интерфейс)
  - [Релейер](#релейер)
- [Принцип работы](#принцип-работы)
  - [Архитектура моста](#архитектура-моста)
  - [Передача сообщений](#передача-сообщений)
  - [Процесс клейма](#процесс-клейма)
  - [Газовые комиссии](#газовые-комиссии)

## Установка

1. Клонирование репозитория:
   ```bash
   git clone <url-репозитория>
   cd <директория-проекта>
   ```

2. Установка зависимостей:
   ```bash
   npm install
   ```

3. Убедитесь, что у вас настроен доступ к тестовым сетям Scroll:
   - L1 сеть: Sepolia (https://ethereum-sepolia-rpc.publicnode.com)
   - L2 сеть: Scroll Sepolia (https://scroll-sepolia-rpc.publicnode.com)

## Конфигурация

Проект использует Hardhat для деплоя контрактов и выполнения скриптов. Конфигурация находится в `hardhat.config.js`.

Основные файлы:
- `contracts/` - смарт-контракты (токены L1/L2 и мосты)
- `scripts/` - скрипты для деплоя и верификации контрактов
- `user_scripts/` - скрипты для взаимодействия с мостом (перевод и клейм токенов)
- `frontend/` - веб-интерфейс для взаимодействия с мостом
- `relayer/` - сервис для автоматического клейма токенов
- `addresses.json` - адреса задеплоенных контрактов (генерируется автоматически)

## Использование

### Деплой контрактов

Для деплоя всех необходимых контрактов выполните (не забудьте указать приватные ключи в `hardhat.config.js`):

```bash
npm run deploy
```

Этот скрипт выполнит следующие действия:
1. Деплой L1CustomToken на L1
2. Деплой L1TokenBridge на L1
3. Деплой L2TokenBridge на L2
4. Деплой L2CustomToken на L2
5. Инициализацию обоих мостов
6. Сохранение адресов контрактов в `addresses.json`

### Верификация контрактов

Для верификации контрактов на Etherscan и Scrollscan:

```bash
npm run verify
```

Этот скрипт автоматически верифицирует все контракты (и на L1, и на L2) с помощью API соответствующих сканеров (Настраивается в `hardhat.config.js`).

### Перевод токенов с L1 на L2

```bash
npm run bridgel1tol2
```

Этот скрипт:
1. Запрашивает ваш приватный ключ
2. Проверяет наличие токенов на L1
3. Одобряет мост на использование токенов
4. Отправляет токены через мост на L2
5. Выводит хэш транзакции

### Перевод токенов с L2 на L1

```bash
npm run bridgel2tol1
```

Этот скрипт:
1. Запрашивает ваш приватный ключ
2. Проверяет наличие токенов на L2
3. Рассчитывает газовую комиссию для выполнения транзакции на L1
4. Отправляет токены через мост на L1
5. Выводит хэш транзакции и ID сообщения для последующего клейма

### Клейм токенов с L2 на L1

После отправки токенов с L2 на L1 необходимо выполнить процедуру клейма для получения токенов на L1:

```bash
npm run claiml2tol1
```

Этот скрипт:
1. Запрашивает хэш транзакции перевода с L2 на L1
2. Получает доказательство через API Scroll
3. Выполняет клейм токенов на L1

### Веб-интерфейс

Проект включает веб-интерфейс для удобного взаимодействия с мостом. Для запуска локально:

1. Убедитесь, что все контракты задеплоены и верифицированы
2. Настройте в файле `app.js` адреса ваших контрактов
3. Запустите локальный веб-сервер Python:
   ```bash
   cd frontend
   python -m http.server 8000
   ```
4. Откройте в браузере адрес: http://localhost:8000

Веб-интерфейс позволяет:
- Просматривать баланс токенов на L1 и L2
- Выполнять переводы токенов между сетями
- Отслеживать статус транзакций
- Выполнять клейм токенов

### Релейер

Для автоматизации процесса клейма токенов с L2 на L1 в проекте реализован релейер. Он автоматически отслеживает новые транзакции и выполняет клейм. Перед запуском необходимо:
1. Указать приватный ключ аккаунта релейера в файле `relayer.py` (можно использовать любой аккаунт, даже не связанный с деплоем)
2. Пополнить этот аккаунт ETH в сети L1 

Для первого запуска релейера установите зависимости (автоматически):
```bash
./deploy_relayer.sh
```

Для следующих запусков можно использовать команду

```bash
./run_relayer.sh
```

Релейер будет:
- Отслеживать новые транзакции в очереди сообщений
- Получать доказательства через API Scroll
- Автоматически выполнять клейм токенов
- Вести лог обработанных транзакций

## Принцип работы

### Архитектура моста

Система состоит из четырех основных компонентов:
1. **L1CustomToken** - ERC20 токен на Ethereum (L1)
2. **L2CustomToken** - ERC20 токен на Scroll (L2), совместимый с интерфейсом IScrollERC20Extension
3. **L1TokenBridge** - мост на L1, отвечающий за блокировку токенов и отправку сообщений на L2
4. **L2TokenBridge** - мост на L2, отвечающий за минтинг/сжигание токенов и отправку сообщений на L1

Мосты взаимодействуют с системными контрактами Scroll:
- **L1ScrollMessenger** - контракт на L1 для отправки сообщений на L2
- **L2ScrollMessenger** - контракт на L2 для отправки сообщений на L1

### Передача сообщений

#### L1 → L2 (Депозит):
1. Пользователь вызывает `bridgeToken` на L1TokenBridge, передавая ETH для оплаты газа на L2
2. L1TokenBridge переводит токены с кошелька пользователя на себя (lock)
3. L1TokenBridge формирует сообщение с вызовом `finalizeDepositERC20` и отправляет его через L1ScrollMessenger
4. Сообщение попадает в L1MessageQueue
5. Релеер Scroll обнаруживает сообщение и отправляет его на L2
6. На L2 вызывается L2TokenBridge.finalizeDepositERC20, который минтит токены получателю

#### L2 → L1 (Вывод):
1. Пользователь вызывает `bridgeToken` на L2TokenBridge, передавая ETH для оплаты газа на L1
2. L2TokenBridge сжигает токены пользователя (burn)
3. L2TokenBridge формирует сообщение с вызовом `finalizeWithdrawERC20` и отправляет его через L2ScrollMessenger
4. Сообщение записывается в L2MessageQueue в бинарное дерево Меркла (withdraw tree)
5. Для завершения процесса требуется клейм на L1

### Процесс клейма

После отправки токенов с L2 на L1 требуется дополнительный шаг - клейм:

1. Пользователь получает доказательство Меркла через API Bridge History
2. Пользователь вызывает `relayMessageWithProof` на L1ScrollMessenger, передавая:
   - Адрес отправителя сообщения (L2TokenBridge)
   - Адрес получателя (L1TokenBridge)
   - Значение (обычно 0)
   - Nonce сообщения
   - Данные сообщения (закодированный вызов finalizeWithdrawERC20)
   - Доказательство (batchIndex и merkleProof)
3. L1ScrollMessenger проверяет доказательство и вызывает finalizeWithdrawERC20 на L1TokenBridge
4. L1TokenBridge разблокирует и переводит токены пользователю

### Газовые комиссии

#### L1 → L2:
- Требуется передать ETH вместе с транзакцией для оплаты газа на L2
- Для стандартных операций обычно достаточно 0.01 ETH
- Неиспользованный ETH возвращается отправителю

#### L2 → L1:
- Требуется передать ETH вместе с транзакцией для оплаты газа на L1
- Для расчета комиссии используется формула: L1 gasPrice * gasLimit
- Для стандартных операций обычно достаточно 0.05 ETH (зависит от загрузки L1)

При клейме токенов с L2 на L1 также требуется оплатить газ за выполнение транзакции клейма на L1. 
